# BUAA-OO-Unit1博客作业

## 第一次作业

### 题目概述

读入一个包含加、减、乘、乘方以及括号（其中括号的深度**至多为 1 层**）的**多变量**表达式，输出**恒等变形展开所有括号后**的表达式。

在本次作业中，**展开所有括号**的定义是：对原输入表达式 *E* 做**恒等变形**，得到新表达式 ′*E*′，且 ′*E*′ 中不含有字符 `(` 和 `)` 。

### 架构设计

第一次作业采用课程组所给训练作业的模板，==Parser作为语法解析器==，==Lexer作为此法解析器==，对读到的一行表达式进行解析，存储到==以Factor为接口的各种因子类（ExprFactor、NumFactor、PowFactor）==中，进而根据形式化表达，将这些因子边解析边“套娃”到==Term、Exp==r的容器类中。

完成解析过程后，==单独建立了Mono、Poly类进行输出==。后者是前者的容器类，每一个Mono对象是一个单项式，而每一个因子类、Term类以及Expr类都有一个==toPoly的方法以实现解析到实际输出的转换==，Poly类中有合并运算并化简的方法。

第一次作业由于思想还不够成熟，采用了Pre类进行对输入表达式的预处理，试图通过预处理对空格、前导0以及多余的符号进行处理，但由于技术不精，导致在预处理上出现了许多未知且棘手的问题，详见<a href="#anchor">心得体会第一次作业</a>



![hw1](D:\college\大二下\面向对象\hw1.png)



### 代码度量

写的时候痛苦不堪，~~写完以后一脸镇定~~

主要是Mono这一项那一块比较复杂，原因是之前也提到过了，里面包含了输出一个单项式时的具体逻辑，比如输出x*x而不是x**2

~~真不要脸啊~~

还有就是Parser那一块,涉及到不同语法块的分类解析逻辑，自然代码量和复杂度都要高一点，~~表示心安理得~~

![image-20230318102218777](C:\Users\hzt\AppData\Roaming\Typora\typora-user-images\image-20230318102218777.png)

### 互测以及bug分析

Disable to参加互测（~~悲~~）

##### bug分析：

主要是优化输出时对格式的条件判断容易出现~~掉头发的~~问题：例如x*x比x**2的长度更短，以及系数为正负1时的格式变化等等，过程繁琐。

其次本地测试时存在对含前导0的数的读入的错误：如无法读取808等数字，原因是自己一开始是采取单一检索字符的方式进行是否前导0的逻辑判断，此方法低效而且容易犯错。后来，我选择了使用了==Biginteger==类型变量来存储字符，==有效地规避了对带符号整数和前导0的逻辑判断，使程序更简洁==。

## 第二次作业

### 题目概述

读入**一系列自定义函数的定义**以及一个包含幂函数、三角函数、自定义函数调用的**表达式**，输出**恒等变形展开所有括号后**的表达式。

在本次作业中，**展开所有括号**的定义是：对原输入表达式 E* 做**恒等变形**，得到新表达式 ′*E*′。其中，′*E*′ 中不再含有自定义函数，且只包含**必要的括号**。

### 架构设计

别看题目概述中相比第一次作业~~只是多了几个字~~，差点把那周的我~~送走~~.

显而易见地，根据指导书，我在第一次作业的~~基础上（里面的<a href="#第二次作业的重构故事">重构故事</a>太过血腥）~~增加了三角因子（Sinfactor、Cosfactor）、自定义函数因子（Funcfactor），与之而来的也是对Mono和Poly的~~大改造~~，所幸递归下降法的优雅美依然坚挺，Parser和Lexer类只需根据形式化表达进行相应的增添即可。

你以为说完上面的话就可以提交中测开始睡大觉了吗 hhh

三角因子里面套娃了Expr 甚至Funcfactor也半路杀出来......~~世道都变乱哩~~

![hw2](D:\college\大二下\面向对象\hw2.png)

### 代码度量

上千行咯 ==MILESTONE==

代码复杂度类同第一次

添加的因子类本身都不复杂，因为任务都交给了Parser的解析和Mono、Poly的输出 ~~像极了不懂事的小孩~~

![](D:\college\大二下\面向对象\hw2statistic.PNG)

### 互测以及bug分析

**三角进行求导**时一开始未能对其附带的指数分类讨论：甚至通过第二次作业，我找到了一直以来我对求导这件事的一个错误点。我以为~~世间万物~~求导它都可以遵循一个原则：TA首先是一个ExprFactor---即认为所有因子求导时都先看成一个表达式因子，只不过是一次还是多次的区别,因此我会在求导时都会使用复合函数求导的法则---~~-这可能就是大学生做不出1+1=2的有力证据了，越学越傻。~~ ==正确方式应该对TA的指数进行分类，指数1就别把TA再复合求一次导了==

**函数形参和实参代入**时的开始未能进行先后顺序的区分：这是很容易犯错的地方，而真正决定高不高明的地方在于你怎么去解决它。~~显然，我是下等马~~ 选择了简单易懂的变量名修改的方式对函数的定义式进行初步的解析----但我毕竟还是下等马中的矮将军，我知道变量名应该换成pqr而不是abc（~~快夸我~~）

## 第三次作业

### 题目概述

读入**一系列自定义函数的定义**以及一个包含幂函数、三角函数、自定义函数调用、求导算子的**表达式**，输出**恒等变形展开所有括号后**的表达式。

在本次作业中，**展开所有括号**的定义是：对原输入表达式 E* 做**恒等变形**，得到新表达式 ′*E*′。其中，′*E*′ 中不再含有自定义函数，不再含有求导算子，且只包含**必要的括号**。

### 架构设计

这次作业相比上一次作业又是只多了几个字，而确实这一次写起来的难度要小了很多，这次说的是真的，seriously。

从类图来说也能看出，只是多了Diffactor以及由TA产生的和Expr类的关系。

我这里将==dx（expr）整个当做一个新的因子==，然后将具体的形式化表达添加到了Parser、Lexer中，同时给每一个Factor都实现了一个新的toDiff的方法，其写法上极度类似toPoly，以至于我一度在纠结能不能将他们两个方法合并-----但==合并虽然美，但贪杯后==就是写法的绕，以及参数传递的冗余性（你需要一个参数判断这是求导输出还是原样输出），这对我这种不想~~掉头发的~~菜鸡是极度不友好的。

![hw3](D:\college\大二下\面向对象\hw3.png)

### 代码度量

嗯，代码加的也不多。

若真如老师所说，这第三次作业是整个OO中最难的一次作业的话，那我的前途还是==光明==的。

![](D:\college\大二下\面向对象\hw3代码statistics.PNG)

### 互测以及bug分析

被严总精准操刀：我在输出系数的时候出问题了。虽然我是用Biginteger存系数，但判断是正负1时竟然没~~带~~脑子地用intvalueof方法来比较,导致大数溢出后的判断错误。这种错误我愿称之为==掩耳盗铃==（~~我的成语学得还挺不错的~~）

我~~心肠好~~，没去做Hack别人的~~恶心事~~（能力不够罢了

经过研讨课的交流，我下定决心之后要学会使用python做做自动评测机（菜鸡的伟大梦想）。

## 迭代视角

### 复杂度分析

**hw1与hw2的类复杂度对比分析**

![](D:\college\大二下\面向对象\hw2与hw1.PNG)

hw2的自定义函数增加了输入的复杂性，这可以从Main的复杂性看出来。

同时依旧是MONO、POLY的宝刀不老。

以及增加的三角因子（虽然我其实还是不太明白为什么我hw1会多出来在WMC中的三角因子的比例 很奇怪）

------

**hw1与hw3的方法复杂度对比分析**

![](D:\college\大二下\面向对象\hw1与hw3的对比方法复杂度.PNG)

可以看出来hw3集中在求导方法上进行了添加，这点和指导书的任务是相符的。

------

hw2与hw1的方法复杂度对比分析

<img src="D:\college\大二下\面向对象\hw2与hw3的方法复杂度对比.PNG" style="zoom:50%;" />

Poly.simple方法复杂度陡升，原因在于我想卷一卷性能分，但奈何自己的Arraylist不好进行合并同类项的一般性判断，于是我只能卑微地用特判的方法去能捞即捞地剪佬们不屑的分数-----~~都说是特判了，你懂这里面的shi味有多浓厚了吧~~

## 心得体会

##### 由于在上个学期学习了OOpre的课程，因此新学期开始之时对Java的基本语法知识有了前置基础，这也导致了自己的盲目自信：

<a id="anchor"></a> 

##### ==*第一次作业*==时自己未能及早开始动工，星期二发布题目后一再拖延，what is worse，周四周五因生病导致进度跟不上，最后只能在周六、日疯狂coding，结果代码是完工了，但因时间仓促，屎山遍地，各种测试样例出现各种的bug。在用idea进行调试时，又频频出现idea调试过程中的“系统问题”，即调试过程中变量的值的不确定性——这一度让我陷入迷茫——我甚至只会一遍一遍重新再现调试过程中的bug，这让我调试效率极低，于是乎，在周日中午十二点前，我只能交上一份无效作业。后来，**在助教的指导下，我进行了idea的修复，每当再次出现调试过程中的系统bug时便清除缓存重启idea**，我于周日下午便写出了hw1的正式版代码。

##### 所幸后来课程组很人性化地提供了第一次作业的补交通道，在这里再次感谢课程组！

------

<a id="第二次作业的重构故事"></a> 

##### 在第一次作业时我便确定下来采用递归下降法，但那时仅仅局限于“照猫画虎”的阶段，对Lexer、Parser类的使用机制和作用不清楚，于是使得在==*第二次作业*==增加了大量条件时我选择了“重构”。

##### 这里说的重构并非是采用不同的方法——毕竟我一次也是仿照训练作业的写法使用递归下降——我只是向通过start from scratch（白手起家）的形式加深了自己对语法解析器、词法解析器的作用机的结合理解。同时通过这次“重构”，我对第一次作业因时间匆忙写出的屎山代码进行了格式上的优化：对代码复用块的抽取对冗余属性、方法的剔除等等；进行了逻辑上的优化：确定对表达式中正负符号的处理方法，对pareseFactor后的什么时候需要lexer.next()以对准下一个词法单元的逻辑进行了统一规定等等。

##### 这使得我能最大限度地在hw1的基础上兼容新增加的函数因子和三角因子，同时**hw2的迭代设计也让我体会到了“递归下降”的解析构架的优雅**。

------

##### *第三次作业*是很值得纪念的一次作业。那周发布题目时，老师对第三次作业曾做过这样的评价：这个hw3是OO课程12次作业中难度最大的一次，没有之一。此话一出，让我在周二晚上构思迭代思路时首先心理上举了白旗。

##### 但是通过对**求导因子**的理解，以及对递归下降法的架构的重新整理，我很快确定了自己的代码。于是我很快便在周五上机前完成了hw3——同时通过上机训练的代码，我更加懂得自己在对求导进行处理时与课程组所给训练代码的异曲同工之妙。期间还是出了一些bug，第一次提交评测时竟然出现了cpu_time_limit的罕见错误，后面debug时定位到自己进行链式求导时出现了过多的冗余无效项（0），使得代码运行速度极度变慢——给出一个嵌套函数求导的测试数据时，甚至可以数5秒后才得出结果，而人工给出化简函数后的表达式求导时速度急剧加快——为此，我只在链式求导过程中增加了一句对表达式冗余项进行合并的代码，电脑直接喷射起步。

##### 这让我第一次以如此直观的视角去感受程序运行速度会因为小小一句代码而有天壤之别。

## 总结

##### 痛并快乐着！

希望我能尽早学会自己手搓评测机，体会真正的快乐